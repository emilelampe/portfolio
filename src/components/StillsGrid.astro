---
import { Image } from 'astro:assets';

interface Still {
  src: ImageMetadata;
  filmSlug: string;
}

interface Props {
  stills: Still[];
}

const { stills } = Astro.props;

// Justified gallery algorithm
// Height range for rows - algorithm tries to keep rows within this range
const minRowHeight = 200;   // Minimum acceptable row height
const idealRowHeight = 250; // Preferred row height (will finalize if row looks good at this height)
const maxRowHeight = 350;   // Maximum row height (for last row)
const gap = 8;
const containerWidth = 1200;

interface LayoutImage {
  still: Still;
  aspectRatio: number;
  width: number;
  height: number;
}

interface Row {
  images: LayoutImage[];
  height: number;
  partial?: boolean; // True if row shouldn't stretch to fill width
}

// Calculate aspect ratios
const imagesWithRatio: LayoutImage[] = stills.map((still) => ({
  still,
  aspectRatio: still.src.width / still.src.height,
  width: 0,
  height: 0,
}));

// Helper to calculate row height needed to fill width
function calcRowHeight(images: LayoutImage[]): number {
  const totalGapWidth = (images.length - 1) * gap;
  const availableWidth = containerWidth - totalGapWidth;
  const totalAspectRatio = images.reduce((sum, i) => sum + i.aspectRatio, 0);
  return availableWidth / totalAspectRatio;
}

// Helper to finalize a row
function finalizeRow(images: LayoutImage[]): Row {
  const height = calcRowHeight(images);
  images.forEach((img) => {
    img.width = height * img.aspectRatio;
    img.height = height;
  });
  return { images, height };
}

// Pack images into rows
const rows: Row[] = [];
let currentRow: LayoutImage[] = [];

for (const img of imagesWithRatio) {
  currentRow.push(img);
  const currentHeight = calcRowHeight(currentRow);

  // If row height drops below minimum, we have too many images
  // Remove last image and finalize the row
  if (currentHeight < minRowHeight && currentRow.length > 1) {
    const overflow = currentRow.pop()!;
    rows.push(finalizeRow([...currentRow]));
    currentRow = [overflow];
  }
  // If row height is in the ideal range (not too tall, not too short), finalize it
  // This prefers fewer, larger images when they fit well
  else if (currentHeight >= idealRowHeight && currentHeight <= maxRowHeight && currentRow.length >= 2) {
    rows.push(finalizeRow([...currentRow]));
    currentRow = [];
  }
}

// Handle last row
if (currentRow.length > 0) {
  const calculatedHeight = calcRowHeight(currentRow);

  // For 1-2 leftover images, don't stretch to fill - use ideal height and leave gap
  if (currentRow.length <= 2 && calculatedHeight > maxRowHeight) {
    const rowHeight = idealRowHeight;
    currentRow.forEach((rowImg) => {
      rowImg.width = rowHeight * rowImg.aspectRatio;
      rowImg.height = rowHeight;
    });
    rows.push({ images: currentRow, height: rowHeight, partial: true });
  } else {
    // Normal row - fill the width
    const rowHeight = Math.min(calculatedHeight, maxRowHeight);
    currentRow.forEach((rowImg) => {
      rowImg.width = rowHeight * rowImg.aspectRatio;
      rowImg.height = rowHeight;
    });
    rows.push({ images: currentRow, height: rowHeight });
  }
}
---

<div class="stills-mosaic">
  {rows.map((row) => (
    <div class:list={["stills-row", row.partial && "stills-row--partial"]} style={`height: ${row.height}px; gap: ${gap}px;`}>
      {row.images.map((img) => (
        <a
          href={`/films#${img.still.filmSlug}`}
          class="group block rounded overflow-hidden relative"
          style={row.partial ? `width: ${img.width}px;` : `flex: ${img.aspectRatio};`}
        >
          <Image
            src={img.still.src}
            alt={`Still from ${img.still.filmSlug}`}
            class="w-full h-full object-cover group-hover:scale-[1.02] transition-transform duration-700"
            widths={[400, 600, 800]}
            sizes="(max-width: 768px) 100vw, 50vw"
            quality={80}
          />
          <div class="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors duration-300"></div>
        </a>
      ))}
    </div>
  ))}
</div>

<style>
  .stills-mosaic {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .stills-row {
    display: flex;
    width: 100%;
  }

  .stills-row--partial {
    justify-content: flex-start;
  }

  /* On mobile, stack images vertically */
  @media (max-width: 768px) {
    .stills-row {
      flex-direction: column;
      height: auto !important;
    }

    .stills-row > a {
      flex: none !important;
      aspect-ratio: auto;
    }
  }
</style>
